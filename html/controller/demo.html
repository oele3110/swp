<!DOCTYPE html>
<html>
    <head>
        <meta charset="utf-8">
        <title>Force Layout</title>
    </head>
	<style>
	
		circle {
			stroke: #fff;
			stroke-width: 2px;
		}
		
		path.link {
			fill: none;
			stroke: #fff;
			stroke-width: 4px;
			cursor: default;
		}
		
		div.tooltip {   
			position: absolute;
			text-align: center;
			vertical-align: middle;
			padding: 2px;
			font: 20px 'Courier New';
			background: black;
			border: 2px solid white;
			border-radius: 4px;
			pointer-events: none;
		}
		
	</style>
    <body>
    	<script type="text/javascript" src="http://d3js.org/d3.v3.min.js"></script>
    	<script type="text/javascript">
		document.body.style.backgroundColor = '#000';
	</script>
	<script type="text/javascript">
		
		var width  = window.innerWidth-15,
			height = window.innerHeight-15,
		    padding = 100, // separation between nodes
		    maxRadius = 50; 

		var n = 10, // total number of nodes
		    m = 2; // number of distinct clusters

		var color = d3.scale.category10()
		    .domain(d3.range(10));

		var x = d3.scale.ordinal()
		    .domain(d3.range(m))
		    .rangePoints([0, width], 1);

		var newSource = null,
			newTarget = null;
				
		// create random nodes
		var nodes = d3.range(n).map(function() {
		  var i = Math.floor(Math.random() * m),
		      v = (i + 1) / m * -Math.log(Math.random());
			  
		  return {
			  type: ((x(i) < width/2) ? "attacker" : "target"), 
			  radius: maxRadius,
			  color: ((x(i) < width/2) ? color(3) : color(9)),
			  cx: x(i),
			  cy: height / 2
		  };
		});
		
		// start without links
		var links = [];

		// init force layout
		var force = d3.layout.force()
		    .nodes(nodes)
			.links(links)
			.linkDistance(x(1)-x(0)-maxRadius)
		    .size([width, height])
		    .gravity(0)
		    .charge(-2000)
		    .on("tick", tick);

		// add svg
		var svg = d3.select("body")
			.append("svg")
		    .attr("width", width)
		    .attr("height", height);
			
		// add background color
		//svg.append("rect")
		//    .attr("width", width)
		//    .attr("height", height)
		//    .attr("fill", "black");
	
		// build arrow header of links
		svg.append('svg:defs').append('svg:marker')
			.attr('id', 'end-arrow')
			.attr('viewBox', '0 -5 10 10')
			.attr('refX', 50)
			.attr('markerWidth', 3)
			.attr('markerHeight', 3)
			.attr('orient', 'auto')
			.append('svg:path')
				.attr('d', 'M0,-5L10,0L0,5')
				.attr('fill', '#fff');

		// define tooltip
		var div = d3.select("body")
			.append("div")   
		    .attr("class", "tooltip")             
			.style("opacity", 0);

		// selection of links
		var path = svg.append('svg:g').selectAll('path');
		
		// selection of nodes
		var circle = svg.selectAll("circle")
		    .data(nodes)
		  .enter().append("circle")
		    .attr("r", function(d) { return d.radius; })
		    .style("fill", function(d) { return d.color; })
		    .on("click", click)
			.on("mouseover", function(d) {      
				div.transition()        
					.duration(200)      
					.style("opacity", .75);      
				div.html(d.type)  
					.style("color", "white")
					.style("left", (d3.event.pageX) + "px")     
					.style("top", (d3.event.pageY - 28) + "px");    
			})                  
			.on("mouseout", function(d) {       
				div.transition()        
					.duration(500)      
					.style("opacity", 0);   
			})
			.call(force.drag);

		// iteration of force layout
		function tick(e) {
            path.attr("d", function(d) {
                var dx = d.target.x - d.source.x,
                    dy = d.target.y - d.source.y,
                    dr = 0;
                return "M" +
                    d.source.x + "," +
                    d.source.y + "A" +
                    dr + "," + dr + " 0 0,1 " +
                    d.target.x + "," +
                    d.target.y;
            });
			
			circle
				.each(gravity(.2 * e.alpha))
				.each(collide(.5))
				.attr("cx", function(d) { return d.x; })
				.attr("cy", function(d) { return d.y; });
		}

		// move nodes toward cluster focus
		function gravity(alpha) {
		  return function(d) {
		    d.y += (d.cy - d.y) * alpha;
		    d.x += (d.cx - d.x) * alpha;
		  };
		}

		// resolve collisions between nodes
		function collide(alpha) {
		  var quadtree = d3.geom.quadtree(nodes);
		  return function(d) {
		    var r = d.radius + maxRadius + padding,
		        nx1 = d.x - r,
		        nx2 = d.x + r,
		        ny1 = d.y - r,
		        ny2 = d.y + r;
		    quadtree.visit(function(quad, x1, y1, x2, y2) {
		      if (quad.point && (quad.point !== d)) {
		        var x = d.x - quad.point.x,
		            y = d.y - quad.point.y,
		            l = Math.sqrt(x * x + y * y),
		            r = d.radius + quad.point.radius + (d.color !== quad.point.color) * padding;
		        if (l < r) {
		          l = (l - r) / l * alpha;
		          d.x -= x *= l;
		          d.y -= y *= l;
		          quad.point.x += x;
		          quad.point.y += y;
		        }
		      }
		      return x1 > nx2 || x2 < nx1 || y1 > ny2 || y2 < ny1;
		    });
		  };
		}
		
		// handle click on node
		function click (d) {
			if (d.type === 'attacker') {
				newSource = d;
			} else {
				newTarget = d;
			}
			
			if (!(newSource === null) && !(newTarget === null)) {

                var newLink = {source: newSource, target: newTarget};
		        links.push(newLink);

                updateLinks();
			}
		}
		
		// add new links
		function updateLinks() {
			path = path.data(force.links());

			// update link
			path.attr("class", "link")
            	.attr("marker-end", "url(#end-arrow)");

			// enter link
          	path.enter().append("svg:path")
            	.attr("class", "link")
            	.attr("marker-end", "url(#end-arrow)")
				.on("click", function(d) {console.log(d)} );

			// exit link
			path.exit().remove();
			
			// reset temp vars
			newSource = null;
			newTarget = null;
			
			// restart force layout
			force.start();
		}
		
		// start force layout
		force.start();
    	</script>
	</body>
</html>
